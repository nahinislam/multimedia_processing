# -*- coding: utf-8 -*-
"""Final Project_Nahin.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kcX6XN8K2z6XlbhwFBB5r8OxFXpcq7U4

Automated Leaf Classification using Machine Learning and Image Processing

Md Nahin Islam

U00899990
"""

import zipfile
import pandas as pd
import os

# Upload `leaf.zip` manually via Colab file upload
from google.colab import files
uploaded = files.upload()

# Unzip the uploaded file
with zipfile.ZipFile("leaf.zip", "r") as zip_ref:
    zip_ref.extractall("leaf_dataset")

# Check files
os.listdir("leaf_dataset")

# Load the CSV file
csv_path = "leaf_dataset/leaf.csv"
leaf_df = pd.read_csv(csv_path)

# Separate features and labels
X = leaf_df.iloc[:, 2:]  # 14 features
y = leaf_df.iloc[:, 0]   # Class label

# Split into train/test
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# Standardize features
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

# Train the SVM model
svm_clf = SVC(kernel='rbf', C=1.0, gamma='scale', random_state=42)
svm_clf.fit(X_train_scaled, y_train)

# Predict on the test set
y_pred_svm = svm_clf.predict(X_test_scaled)

# Evaluate
print("‚úÖ SVM Accuracy:", accuracy_score(y_test, y_pred_svm))
print("\nClassification Report:\n", classification_report(y_test, y_pred_svm))

# Plot confusion matrix
plt.figure(figsize=(10, 8))
sns.heatmap(confusion_matrix(y_test, y_pred_svm), annot=True, fmt='d', cmap="Blues")
plt.title("SVM Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

from sklearn.ensemble import RandomForestClassifier

# Train the Random Forest model
rf_clf = RandomForestClassifier(n_estimators=100, random_state=42)
rf_clf.fit(X_train_scaled, y_train)

# Predict and evaluate
y_pred_rf = rf_clf.predict(X_test_scaled)

print("‚úÖ Random Forest Accuracy:", accuracy_score(y_test, y_pred_rf))
print("\nClassification Report:\n", classification_report(y_test, y_pred_rf))

# Confusion Matrix
plt.figure(figsize=(10, 8))
sns.heatmap(confusion_matrix(y_test, y_pred_rf), annot=True, fmt='d', cmap="Greens")
plt.title("Random Forest Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

import os
import torch
import torchvision
from torchvision import transforms, datasets
from torch.utils.data import DataLoader
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

# Transform images to 128x128, convert to tensor, normalize
transform = transforms.Compose([
    transforms.Resize((128, 128)),
    transforms.RandomHorizontalFlip(),
    transforms.RandomRotation(10),
    transforms.ColorJitter(brightness=0.2),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.5]*3, std=[0.5]*3)
])


# Load data from RGB folder
data_dir = "leaf_dataset/RGB"
dataset = datasets.ImageFolder(root=data_dir, transform=transform)

# Split into train/test (80/20)
train_size = int(0.8 * len(dataset))
test_size = len(dataset) - train_size
train_dataset, test_dataset = torch.utils.data.random_split(dataset, [train_size, test_size])

train_loader = DataLoader(train_dataset, batch_size=16, shuffle=True)
test_loader = DataLoader(test_dataset, batch_size=16)

class LeafCNN(nn.Module):
    def __init__(self):
        super(LeafCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 16, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(2, 2)
        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, padding=1)
        self.fc1 = nn.Linear(32 * 32 * 32, 128)
        self.fc2 = nn.Linear(128, 40)  # 40 classes

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))   # 64x64
        x = self.pool(F.relu(self.conv2(x)))   # 32x32
        x = x.view(-1, 32 * 32 * 32)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

cnn_model = LeafCNN()
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
cnn_model.to(device)

#Train CNN
# Loss and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(cnn_model.parameters(), lr=0.001)

# Training loop
num_epochs = 5
for epoch in range(num_epochs):
    cnn_model.train()
    running_loss = 0.0
    correct = 0
    total = 0

    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)

        optimizer.zero_grad()
        outputs = cnn_model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

    print(f"Epoch [{epoch+1}/{num_epochs}], Loss: {running_loss:.4f}, Accuracy: {100 * correct / total:.2f}%")

cnn_model.eval()
correct = 0
total = 0

with torch.no_grad():
    for images, labels in test_loader:
        images, labels = images.to(device), labels.to(device)
        outputs = cnn_model(images)
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

print(f"‚úÖ CNN Test Accuracy: {100 * correct / total:.2f}%")

import matplotlib.pyplot as plt

# Accuracy values
models = ['SVM', 'Random Forest', 'CNN']
accuracies = [69.1, 82.4, 59.6]

# Plot
plt.figure(figsize=(8, 5))
bars = plt.bar(models, accuracies)
plt.title("Model Accuracy Comparison")
plt.ylabel("Accuracy (%)")
plt.ylim(0, 100)

# Add value labels on top of bars
for bar in bars:
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2.0, yval + 1, f"{yval:.1f}%", ha='center', va='bottom')

plt.show()

# üìä Initialize Tracking Lists
train_acc = []
train_loss = []
val_acc = []
val_loss = []

# üîÅ CNN Training + Validation
num_epochs = 20
for epoch in range(num_epochs):
    cnn_model.train()
    running_loss = 0.0
    correct = 0
    total = 0

    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device)

        optimizer.zero_grad()
        outputs = cnn_model(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

        running_loss += loss.item()
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

    acc = 100 * correct / total
    train_loss.append(running_loss)
    train_acc.append(acc)

    # üîç Validation
    cnn_model.eval()
    val_correct = 0
    val_total = 0
    val_running_loss = 0.0
    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = cnn_model(images)
            loss = criterion(outputs, labels)
            val_running_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            val_total += labels.size(0)
            val_correct += (predicted == labels).sum().item()

    val_acc.append(100 * val_correct / val_total)
    val_loss.append(val_running_loss)

    print(f"Epoch [{epoch+1}/{num_epochs}] ‚Äî "
          f"Train Acc: {acc:.2f}%, Train Loss: {running_loss:.2f} | "
          f"Val Acc: {val_acc[-1]:.2f}%, Val Loss: {val_loss[-1]:.2f}")

plt.figure(figsize=(12, 5))

# Accuracy
plt.subplot(1, 2, 1)
plt.plot(train_acc, label="Train Accuracy", marker='o')
plt.plot(val_acc, label="Val Accuracy", marker='x')
plt.title("CNN Accuracy per Epoch")
plt.xlabel("Epoch")
plt.ylabel("Accuracy (%)")
plt.legend()

# Loss
plt.subplot(1, 2, 2)
plt.plot(train_loss, label="Train Loss", marker='o', color='red')
plt.plot(val_loss, label="Val Loss", marker='x', color='orange')
plt.title("CNN Loss per Epoch")
plt.xlabel("Epoch")
plt.ylabel("Loss")
plt.legend()

plt.tight_layout()
plt.show()

from sklearn.metrics import classification_report, confusion_matrix
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Collect predictions and true labels
cnn_model.eval()
all_preds = []
all_labels = []

with torch.no_grad():
    for images, labels in test_loader:
        images = images.to(device)
        outputs = cnn_model(images)
        _, predicted = torch.max(outputs.data, 1)
        all_preds.extend(predicted.cpu().numpy())
        all_labels.extend(labels.numpy())

# Classification Report
print("‚úÖ CNN Classification Report:\n")
print(classification_report(all_labels, all_preds))

# Confusion Matrix
cm = confusion_matrix(all_labels, all_preds)

plt.figure(figsize=(10, 8))
sns.heatmap(cm, annot=True, fmt='d', cmap="Purples")
plt.title("CNN Confusion Matrix")
plt.xlabel("Predicted")
plt.ylabel("Actual")
plt.show()

!pip install gradio

import gradio as gr
from PIL import Image

def predict_leaf_gradio(image):
    image = image.convert('RGB')
    input_tensor = transform(image).unsqueeze(0).to(device)

    cnn_model.eval()
    with torch.no_grad():
        output = cnn_model(input_tensor)
        _, predicted = torch.max(output, 1)

    class_name = dataset.classes[predicted.item()]
    return f"üåø Predicted Species: {class_name}"

iface = gr.Interface(
    fn=predict_leaf_gradio,
    inputs=gr.Image(type="pil"),
    outputs="text",
    title="Real-Time Leaf Identification System üåø",
    description="Upload a leaf image and get its predicted species using a trained CNN model."
)

iface.launch()